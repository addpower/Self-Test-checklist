## 目录

1. **[理解词法作用域和动态作用域](#理解词法作用域和动态作用域)**
1. **[理解 JavaScript 的作用域和作用域链](#理解-javascript-的作用域和作用域链)**
1. **[理解 JavaScript 的执行上下文栈,可以应用堆栈信息快速定位问题](#理解-javascript-的执行上下文栈可以应用堆栈信息快速定位问题)**
1. **[this 的原理以及几种不同使用场景的取值](#this-的原理以及几种不同使用场景的取值)**
1. **[闭包的实现原理和作用](#闭包的实现原理和作用)**
1. **[理解堆栈溢出和内存泄漏的原理,如何防止](#理解堆栈溢出和内存泄漏的原理如何防止)**
1. **[如何处理循环的异步操作](#如何处理循环的异步操作)**
1. **[理解模块化解决的实际问题,可列举几个模块化方案并理解其中原理](#Module)缺**

### 理解词法作用域和动态作用域

#### 作用域

作用域是指程序源代码中定义变量的区域。
作用域规定了如何查找变量,也就是确定当前执行代码对变量的访问权限。
JavaScript 采用词法作用域(lexical scoping),也就是静态作用域。

#### 静态作用域与动态作用域

因为 JavaScript 采用的是词法作用域,函数的作用域在函数定义的时候就决定了,而词法作用域相对的是动态作用域,函数的作用域是在函数调用的时候才决定的。

[:arrow_up:返回目录](#目录)

### 理解 JavaScript 的作用域和作用域链

#### 什么是作用域？

作用域是在运行时代码中的某些特定部分中变量,函数和对象的可访问性。换句话说,作用于决定了代码区块中变量和其他资源的可见性。
作用域就是一个独立的地盘,让变量不会外泄,暴露出去。
作用域最大的用处就是隔离变量,不同作用域下同名变量不会有冲突。
ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。ES6 的到来,为我们提供了'块级作用域',可通过新增命令 let 和 const 来体现。

> - 全局作用域和函数作用域
>   - 最外层函数和最外层函数外面定义的变量拥有全局作用域
>   - 所有未定义直接赋值的变量自动声明为拥有全局作用域
>   - 所有 window 对象的属性拥有全局作用域

全局作用域有个弊端：如果我们写了很多 JS 代码,变量定义都没有用函数包括,那么他们就全部都在全局作用域中。这样就会污染全局命名空间,容易引起命名冲突。

> 作用域是分层的,内层作用域可以访问外层作用域的变量,反之则不行。

```
值得注意的是：块语句(大括号"{}"中间的语句),
如if和switch条件语句或for和while循环语句,不像函数,它们不会创建一个新的作用域。
```

> - 块级作用域
>   - 在一个函数内部创建
>   - 在一个代码块(由一对花括号包裹)内部

- 块级作用域有以下几个特点
  - 声明变量不会提升到代码块顶部
  - 禁止重复声明
  - 循环中的绑定块作用域

#### 作用域链

作用域中所存储的执行期上下文对象的集合,这个集合呈链式链接,我们把这种链式链接叫做作用域链。

[:arrow_up:返回目录](#目录)

### 理解 JavaScript 的执行上下文栈,可以应用堆栈信息快速定位问题

#### 什么是执行上下文？

```
简而言之,执行上下文是评估和执行JavaScript代码的环境的抽象概念。
每当JavaScript代码运行的时候,它都是在执行上下文中运行。
```

#### 执行上下文类型

> - JavaScript 中有三种执行上下文类型
>   - **全局执行上下文**
>     - 这是默认或者说基础的上下文,任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象(浏览器的情况下),并且设置**this**的值等于这个全局对象。一个程序中会有一个全局执行上下文。
>   - **函数执行上下文**
>     - 每当一个函数被调用时,都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文,不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建,它会按定义的顺序执行一系列步骤。
>   - **Eval 函数执行上下文**
>     - 执行在 eval 函数内部的代码也会有它属于自己的执行上下文。

#### 运行期上下文

当函数执行时,会创建一个称为执行器上下文的内部对象,一个执行期上下文定义了一个函数执行时的环境,函数每次执行时对应的执行上下文都是独一无二的,所以多次调用一个函数会导致创建多个执行上下文,当函数执行完毕,它所产生的执行上下文被销毁。

#### [深入理解JavaScript执行上下文、函数堆栈、提升的概念](https://segmentfault.com/a/1190000009041008)
[:arrow_up:返回目录](#目录)

### this 的原理以及几种不同使用场景的取值

**JavaScript 中 this 含义完全取决于函数调用方式**

> - JavaScript 中函数的调用有以下几种方式
>   - 作为对象方法调用
>   - 作为函数调用
>   - 作为构造函数调用
>   - 使用 apply 或 call 调用

#### 作为对象调用

在 JavaScript 中,函数也是对象,因此函数可以作为一个对象的属性,此时该函数被称为该对象的方法,this 被自然绑定到该对象。

#### 作为函数调用

函数也可以直接被调用,此时 this 绑定到全局对象。在浏览器中,window 就是该全局对象。

#### 作为构造函数调用

JavaScript 支持面向对象式编程,不过 JavaScript 并没有类(class)的概念,而是使用基于原型(prototype)的继承方式。【构造函数以大写字母开头】。
在内部函数中,即声明在另外一个函数体内的函数,这种绑定到全局对象的的方式会产生另外一个问题。我们需要在内部函数中创建变量存下外部函数的 this,该变量一般命名为 that。

#### 在 call 或者 apply 中调用

他们允许切换函数执行上下文环境(context),即 this 绑定的对象。

[:arrow_up:返回目录](#目录)

### 闭包的实现原理和作用

#### 闭包：

> 当内部函数被保存到外部时会产生闭包。闭包会导致原有作用域链不释放,造成内存泄漏。

#### 闭包的作用：

> - 实现公有变量 => 累加器
> - 可以做缓存,存储结构
> - 可以实现封装,属性私有化
> - 模块化开发,防止污染全局变量

#### 如何快速判断闭包：

> - 三个特点：
>   - 1.  闭包一定具有嵌套函数
>   - 2.  内层函数一定操作了外层函数的局部变量
>   - 3.  外层函数,将内层函数返回到外部,变量接住(全局变量)

#### 闭包的执行结果

> - 外层函数被调用几次,就有几个受保护的局部变量副本
> - 来自一个闭包的函数被调用几次,受保护的局部变量就变化几次

```javascript{.line-numbers}
/** 累加器*/
function add() {
  var count = 0;
  function demo() {
    count++;
    console.log(count);
  }
  return demo;
}

var counter = add();
counter();
```

[:arrow_up:返回目录](#目录)

### 理解堆栈溢出和内存泄漏的原理,如何防止

内存泄漏(memory leak)的堆积最终会导致内存溢出(out of memory)

#### 内存泄漏 memory leak

是指程序在**申请内存后,无法释放已申请的内存空间,**一次内存泄漏似乎不会有大的影响,但内存泄漏堆积后的后果就是内存溢出。

#### 内存溢出 out of memory

指程序申请内存时,**没有足够的内存供申请者使用,**或者说,给了你一块存储 int 类型数据的存储空间,但是你却存储 long 类型的数据,那么结果就是内存不够用,此时就会报错,即所谓的内存溢出。

#### 二者的关系

内存泄漏的堆积最终会导致内存溢出。

#### 内存溢出的原因

1. 内存中**加载的数据量过于庞大**,如一次从数据库取出过多的数据。
1. 集合类中**有对对象的引用,使用完后未清空**,使得 JVM 不能回首。
1. 代码中存在**死循环**或循环产生过多重复的对象实体。
1. 使用的第三方软件中的 BUG。
1. **启动参数内存值设定过小**

#### 内存溢出的解决方案

```
第一步,修改JVM启动参数,直接增加内存。(-Xms,-Xmx参数一定不要忘记加。)
第二步,检查错误日志,查看“OutOfMemory”错误前是否有其 它异常或错误。
第三步,对代码进行走查和分析,找出可能发生内存溢出的位置。
 - 重点排查以下几点：
    -   1.检查对数据库查询中,是否有一次获得全部数据的查询。
    一般来说,如果一次取十万条记录到内存,就可能引起内存溢出。
    这个问题比较隐蔽,在上线前,数据库中数据较少,不容易出问题,上线后,数据库中数据多了,
    一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。
    -   2.检查代码中是否有死循环或递归调用。
    -   3.检查是否有大循环重复产生新对象实体。
    -   4.检查List、MAP等集合对象是否有使用完后,未清除的问题。
    List、MAP等集合对象会始终存有对对象的引用,使得这些对象不能被GC回收。
第四步,使用内存查看工具动态查看内存使用情况
```

[:arrow_up:返回目录](#目录)

### 如何处理循环的异步操作

**如何确保循环的所有异步操作完成之后执行某个其他操作**
```javascript{.line-numbers}
/**设置一个flag,在每个一步操作中对flag进行检测*/
let flag = 0;
for(let i = 0; i < len; i++) {
  flag++;
  Database.save_method().exec().then((data) => {
      if(flag === len) {
            // your code
      }
  })
}
```

```javascript{.line-numbers}
/**将所有的循环放在一个promise中,使用then处理*/
 new Promise(function(resolve){
      resolve()
 }).then(()=> {
     for(let i = 0; i < len; i++) {
           Database.save_method().exec()
     }
}).then(() => {
    // your code
})
```
**循环中的下一步操作依赖于前一步的操作**

```javascript{.line-numbers}
/**使用递归,再异步操作完成之后调用下一步异步操作*/
function loop(i){
  i++;
  Database.save_method().exec().then(() => {
      loop(i)
    })
}
```

```javascript{.line-numbers}
/**使用 async 和 await */
async function loop() {
    for(let i = 0; i < len; i++) {
         await Database.save_method().exec();
    }
}
```

[:arrow_up:返回目录](#目录)

### 理解模块化解决的实际问题,可列举几个模块化方案并理解其中原理
