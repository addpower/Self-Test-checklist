## 目录

1. **[理解词法作用域和动态作用域](#scope)**
1. **[理解JavaScript的作用域和作用域链](#Jscope)**
1. **[理解JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题](#UpDown)**
1. **[this的原理以及几种不同使用场景的取值](#this)**


### <h3 id="scope">理解词法作用域和动态作用域<h3>

#### 作用域

作用域是指程序源代码中定义变量的区域。
作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。
JavaScript采用词法作用域(lexical scoping),也就是静态作用域。

#### 静态作用域与动态作用域

因为JavaScript采用的是词法作用域，函数的作用域在函数定义的时候就决定了，而词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。

[:arrow_up:返回目录](#目录)

### <h3 id="Jscope">理解JavaScript的作用域和作用域链<h3>

#### 什么是作用域？
作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用于决定了代码区块中变量和其他资源的可见性。
作用域就是一个独立的地盘，让变量不会外泄，暴露出去。
作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。
ES6之前JavaScript没有块级作用域，只有全局作用域和函数作用域。ES6的到来，为我们提供了'块级作用域'，可通过新增命令let和const来体现。

> - 全局作用域和函数作用域
>   - 最外层函数和最外层函数外面定义的变量拥有全局作用域
>   - 所有未定义直接赋值的变量自动声明为拥有全局作用域
>    - 所有window对象的属性拥有全局作用域

全局作用域有个弊端：如果我们写了很多JS代码，变量定义都没有用函数包括，那么他们就全部都在全局作用域中。这样就会污染全局命名空间，容易引起命名冲突。
> 作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行。
```
值得注意的是：块语句(大括号"{}"中间的语句)，
如if和switch条件语句或for和while循环语句，不像函数，它们不会创建一个新的作用域。
```
> - 块级作用域
>   - 在一个函数内部创建
>   - 在一个代码块(由一对花括号包裹)内部

 - 块级作用域有以下几个特点
    - 声明变量不会提升到代码块顶部
    - 禁止重复声明
    - 循环中的绑定块作用域

#### 作用域链
作用域中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这种链式链接叫做作用域链。


[:arrow_up:返回目录](#目录)

### <h3 id="UpDown">理解JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题<h3>

#### 什么是执行上下文？
```
简而言之，执行上下文是评估和执行JavaScript代码的环境的抽象概念。
每当JavaScript代码运行的时候，它都是在执行上下文中运行。
```

#### 执行上下文类型
> - JavaScript中有三种执行上下文类型
>   -  **全局执行上下文**
>       -   这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的window对象(浏览器的情况下)，并且设置**this**的值等于这个全局对象。一个程序中会有一个全局执行上下文。
>   -   **函数执行上下文**
>       -   每当一个函数被调用时，都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序执行一系列步骤。
>   - **Eval函数执行上下文**
>       - 执行在eval函数内部的代码也会有它属于自己的执行上下文。

#### 运行期上下文
当函数执行时，会创建一个称为执行器上下文的内部对象，一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，它所产生的执行上下文被销毁。

[:arrow_up:返回目录](#目录)

### <h3 id="this">this的原理以及几种不同使用场景的取值<h3>
**JavaScript中this含义完全取决于函数调用方式**
>   -  JavaScript中函数的调用有以下几种方式
>       - 作为对象方法调用
>       - 作为函数调用
>       - 作为构造函数调用
>       - 使用apply或call调用

#### 作为对象调用
在JavaScript中，函数也是对象，因此函数可以作为一个对象的属性，此时该函数被称为该对象的方法，this被自然绑定到该对象。

#### 作为函数调用
函数也可以直接被调用，此时this绑定到全局对象。在浏览器中，window就是该全局对象。

#### 作为构造函数调用
JavaScript支持面向对象式编程，不过JavaScript并没有类(class)的概念，而是使用基于原型(prototype)的继承方式。【构造函数以大写字母开头】。
在内部函数中，即声明在另外一个函数体内的函数，这种绑定到全局对象的的方式会产生另外一个问题。我们需要在内部函数中创建变量存下外部函数的this，该变量一般命名为that。

#### 在call或者apply中调用
他们允许切换函数执行上下文环境(context)，即this绑定的对象。

[:arrow_up:返回目录](#目录)

