## 目录

1. **[理解原型设计模式以及 JavaScript 中的原型规则](#Prototype-pattern)**
1. **[instanceof 的底层实现原理，手动实现一个 instanceof](#instanceof)**

### <h3 id="Prototype-pattern">理解原型设计模式以及 JavaScript 中的原型规则<h3>

#### 什么是原型模式

**原型模式(Prototype pattern)**:`通俗点讲就是创建一个共享的原型，并通过拷贝这些原型创建新的对象。 用于创建重复的对象，这种类型的设计模式属于创建型模式，它提供了一种创建对象得比错选择。`

#### 实现原型模式

我们可以通过 JavaScript 特有的原型集成特性去实现原型模式，也就是创建一个对象作为另一个对象的 prototype 属性值，我们可以通过 Object.create(prototype,optionalDescriptorObjects)来实现原型继承。

```javascript{.line-numbers}
var fatherPrototype = {
  init: function(money) {
    this.selfMoney = money;
  },
  getMoney: function() {
    console.log("取钱" + this.selfMoney);
  }
};

function sonMoney(Smoney) {
  function F() {}
  F.prototype = fatherPrototype;
  var f = new F();
  f.init(Smoney);
  return f;
}

var sonGetMoney = sonMoney("20");
sonGetMoney.getMoney();
//儿子取钱取得是他爹的
```

**原型模式，就是创建一个共享的原型，通过拷贝这个原型来创建新的类，用于创建重复的对象，带来性能上的提升。**

[:arrow_up:返回目录](#目录)

### <h3 id="instanceof">instanceof 的底层实现原理，手动实现一个 \_instanceof<h3>

先来看个例子

```javascript{.line-numbers}
function Person(name, age) {
  this.name = name;
  this.age = age;
}

function Student(score) {
  this.score = score;
}

Student.prototype = new Person("李明", 22);
var s = new Student(99);

console.log(s instanceof Student); //true
console.log(s instanceof Person); //true
console.log(s instanceof Object); //true
```

检测对象 A 是不是另一个对象 B 的实例的原理：**查看对象 B 的 prototype 属性指向的原型对象是否在对象 A 的原型上，若在则返回 true，若不在则返回 false。**

```javascript{.line-number}
function _instanceof(ins, cons) {
  while (true) {
    if (ins.__proto__ === null) {
      return false;
    }
    if (ins.__proto__ === cons.prototype) {
      return true;
    }
    ins = ins.__proto__;
  }
}
```

\_instanceof 实际上是根据原型链向上追溯，子类找不到找父类，直到 ins.\_\_proto\_\_指向的就是 cons.prototype,否则，当 ins 已经追溯到 Object.prototype，由于 Object.prototype 是没有\_\_proto\_\_的，所以当 ins.\_\_proto\_\_ === null 时，就说明我们的循环到最后也没有成功使 ins.\_\_proto\_\_ === cons.prototype，那么 ins 就不是 cons 或 cons 的子类实例化出来的对象，函数返回 false。
