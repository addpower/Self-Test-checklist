## 目录

1. **[为何 try 里面放 return，finally 还会执行，理解其内部机制](#try)**
1. **[JavaScript 如何实现异步编程，可以详细描述 EventLoop 机制](#asynchronous)**
1. **[宏任务和微任务分别有哪些](#)**
1. **[可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法](#)**
1. **[使用 Promise 实现串行](#)**
1. **[Node 与浏览器 EventLoop 的差异](#)**
1. **[如何在保证页面运行流畅的情况下处理海量数据](#)**

### <h3 id="try">为何 try 里面放 return，finally 还会执行，理解其内部机制<h3>

try-catch 是捕捉异常的神奇，不管是调试还是防止软件崩溃，都离不开它。

```javascript{.line-numbers}
function test(){
    try{
        console.log(1);
    }finally{
        condole.log(2);
    }
}

console.log(test());
<!-- 1  2 -->
//结果：它按顺序执行了
```

```javascript{.line-numbers}
//在 try 中加入 return 语句
function test(){
    try{
        console.log(1);
        return 'try';
    }catch(e){
        //TODO
    }finally{
        console.log(2);
    }
}

console.log(test());
<!-- 1 2 try -->
//在 try和 catch的代码块中，如果碰到 return语句，那么在 return之前，会先执行finally中的内容
```

```javascript{.line-numbers}
//在 finally中也加入 return语句
function test(){
    try{
        console.log(1);
        return 'try';
    }catch(e){
        //TODO
    }finally{
        console.log(2);
        return 'finally';
    }
}

console.log(test());
<!-- 1 2 finally -->
//按照上一条规则，finally是会先执行的，所以如果 finally里有 return语句，那么就真的return了。
```

#### 结论：

> 1. 不管有没有异常，finally 块中代码都会执行
> 1. 当 try 和 catch 中有 return 时，finally 仍然会执行
> 1. finally 是在 return 后面的表达式运算后执行的(此时并没有返回运算后的值，而是先把要返回的值保存起来，管 finally 中的代码怎么样，返回的值都不会改变，仍然是之前保存的值)，

    所以函数返回值是在 finally 执行前确定的。

> 1. finally 中最好不要包含 return，否则程序会提前退出，返回值不是 try 或 catch 中保存的返回值。

>    **任何执行 try 或者 catch 中的 return 语句之前，都会先执行 finally 语句(如果 finally 存在的话)**

#### 内部机制

在 try 语句中，在执行 return 语句时，要返回的结果已经准备好了，就在此时，程序转到 finally 执行了。在转去之前，try 中先把要返回的结果存放到不同于 x 的局部变量中去，执行完 finally 之后，再从中取出返回结果。
因此，即使 finally 中对变量 x 进行了改变，但是不会影响返回结果。
他应该使用栈保存返回值。

```javascript{.line-numbers}
//测试
function test(){
 	var x = 1;
	try{
		x++;
		return x;
    }
	finally{
	    ++x;
    }
}


console.log(test());
<!-- 2 -->
```

[:arrow_up:返回目录](#目录)

### <h3 id="asynchronous">JavaScript 如何实现异步编程，可以详细描述 EventLoop 机制<h3>

> 同步编程：即是一种典型的请求——响应模型，当请求调用一个函数或方法后，需等待其响应返回，然后执行后续代码。

一般情况下，同步编程，即是按照代码顺序依次执行，能很好的保证程序的执行，但在某些场景下，比如加载文件内容，请求数据等需要返回大量的内容时，耗费时间较长，此时程序不能继续向下运行，这显然是不友好的。这正需要异步编程大显身手！

> 异步编程：不同于同步编程的请求——响应模式，其是一种事件驱动编程，请求调用函数或方法后，无需立即等待响应，可以继续执行其他任务，而在之前任务响应返回后可以通过状态、通知和回调来通知调用者。

> 通常实现异步方式是多线程，如 C#，即同时开启多个线程，不同操作能并行执行。

> JavaScript 语言试单线程，单线程在程序执行时，所走的程序路径是按照连续顺序排下来的。前面必须处理好，后面才会执行。前面代码报错，后面的程序将不会执行。
>
> - JavaScript 单线程异步编程可以实现多任务并发执行。 - 并行：指同一时刻内多任务同时进行 - 并发：指在同一时间段内，多任务同时进行着，但是某一时刻，只有某一任务执行。

#### 并发模型

JavaScript 异步编程使得多个任务可以并发执行，而实现这一功能的基础是 JavaScript 拥有一个基于事件循环的并发模型

> - 堆栈与队列 - 堆：内存中某一未被阻止的区域，通常存储对象(引用类型); - 栈：后进先出的顺序存储数据结构，通常存储函数参数和基本类型数值变量(按值访问); - 队列：先进先出顺序存储数据结构

#### 事件循环

JavaScript 引擎负责解析，执行 JavaScript 代码，但它不能单独运行，而需要一个宿主环境，一般为浏览器。调用 Javascript 引擎完成多个 javaScript 代码块的调度，执行，这种机制就称为事件循环。

> - JavaScript 执行环境中存在的两个结构需要了解： - 消息队列:也叫任务队列，存储待处理消息及对应的回调函数或事件处理程序。 - 执行栈：也叫执行上下文栈，JavaScript 执行栈，顾名思义，是由执行上下文组成，当函数调用时，创建并插入一个执行上下文，通常称为栈帧，存储着函数参数和局部变量，当该函数执行结束时，弹出该执行栈帧。

#### 事件循环流程

> 1. 宿主环境为 JavaScript 创建线程时，会创建堆(heap)和栈(stack)，堆内存储 JavaScript 对象，栈内存储执行上下文；
> 1. 栈内执行上下文的同步任务按序执行，执行完即退栈，而当异步任务执行时，该异步任务进入等待状态（不入栈），同时通知线程：当触发该事件时（或该异步操作响应返回时），需向消息队列插入一个事件消息；
> 1. 当事件触发或响应返回时，线程向消息队列插入该事件消息（包含事件及回调）；
> 1. 当栈内同步任务执行完毕后，线程从消息队列取出一个事件消息，其对应异步任务（函数）入栈，执行回调函数，如果未绑定回调，这个消息会被丢弃，执行完任务后退栈；
> 1. 当线程空闲（即执行栈清空）时继续拉取消息队列下一轮消息（next tick，事件循环流转一次称为一次 tick）。

#### setTimeout

在``setTimeout``异步回调函数里当我们输出异步任务注册到执行的时间，发现并不等于我们指定的时间，而且多次执行时间隔也不同！

> - 在读取消息队列的消息时，得等同步任务完成，这个是需要耗费时间的
> - 消息队列先进先出原则，读取此异步事件消息之前，可能还存在其他消息，执行也需要消耗

所以异步执行时间不精确是必然的。

#### JavaScript异步实现

关于JavaScript的异步实现，以前有：回调函数，发布订阅模式，Promise三类，而在ES6中提出了生成器(Generator)方式实现。