## 目录

1. **[JavaScript 规定了几种语言类型](#javascript-规定了几种语言类型)**
1. **[null 和 undefined 的区别](#null-和-undefined-的区别)**
1. **[JavaScript 数字精度问题](#javascript-数字精度问题)**
1. **[JavaScript 中的变量在内存中的具体存储形式](#javascript-中的变量在内存中的具体存储形式)**
1. **[理解值类型和引用类型](#理解值类型和引用类型)**
1. **[JavaScript 对象的底层数据结构是什么](#javascript-对象的底层数据结构是什么)**
1. **[三种判断 JavaScript 数据类型的方式](#三种判断-javascript-数据类型的方式)**
1. **[隐式类型转换的场景及转换原则](#隐式类型转换的场景及转换原则)**
1. **[基本类型对应的内置对象，以及他们之间的装箱拆箱操作](#基本类型对应的内置对象以及他们之间的装箱拆箱操作)**
1. **[Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol](#Symbol)  ``缺``**

### JavaScript 规定了几种语言类型

详情请点击[JavaScript 的数据类型及其检测](http://note.youdao.com/noteshare?id=90745a65f3ab66d6383c4c2174682017&sub=6EE107F89A5D46D19362566E68D39FAB "点击查看")

Javascript 有两种数据类型，分别是`基本数据类型`和`引用数据类型`。其中基本数据类型包括 `Undefined`、`Null`、`Boolean`、`Number`、`String`、`Symbol` (ES6 新增，表示独一无二的值)，而引用数据类型统称为 Object 对象，主要包括对象、数组和函数。

### 基础数据类型

#### 1.值是不可变的

#### 2.存放在栈区

#### 3.值的比较

### 引用数据类型

#### 1.值是可变的

#### 2.同时保存在栈内存和堆内存

#### 3.比较是引用的比较

### 检验数据类型

#### 1.typeof

typeof 返回一个表示数据类型的字符串，返回结果包括：`number`、`boolean`、`string`、`symbol`、`object`、`undefined`、`function` 等 7 种数据类型，但不能判断 null、array 等
数组和对象返回的都是 object，这时就需要使用 instanceof 来判断

```
typeof Symbol(); // symbol 有效
typeof ''; // string 有效
typeof 1; // number 有效
typeof true; //boolean 有效
typeof undefined; //undefined 有效
typeof new Function(); // function 有效
typeof null; //object 无效
typeof [] ; //object 无效
typeof new Date(); //object 无效
typeof new RegExp(); //object 无效
```

#### 2.instanceof

instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。

```
[] instanceof Array; //true
{} instanceof Object;//true
new Date() instanceof Date;//true
new RegExp() instanceof RegExp//true
```

关于数组的类型判断，还可以用 ES6 新增 Array.isArray()

```
Array.isArray([]);   // true
```

#### 3.严格运算符===

只能用于判断 null 和 undefined，因为这两种类型的值都是唯一的。
undefined 还可以用 typeof 来判断

#### 4.constructor

constructor 作用和 instanceof 非常相似。但 constructor 检测 Object 与 instanceof 不一样，还可以处理基本数据类型的检测。

[:arrow_up:返回目录](#目录)

### null 和 undefined 的区别

null 是 JavaScript 语言的关键字，他表示一个特殊值【特殊的对象值，含义是“非对象”】，常用来描述“空值”。

```javascript
typeof(null) ==> "object";
```

undefined 是预定义的全局变量（他和 null 不一样,他不是关键字），他的值就是“未定义”。

```javascript
typeof(undefined) ==> "undefined";
表明这个值是这个类型的唯一成员。
```

```javascript
null == undefined  ==>true
null === undefined   ==> false
```

[:arrow_up:返回目录](#目录)

### JavaScript 数字精度问题

#### 出现原因

Javascript 采用了 IEEE-745 浮点数表示法（几乎所有的编程语言都采用），这是一种二进制表示法，可以精确地表示分数，比如 1/2，1/8，1/1024。遗憾的是，我们常用的分数（特别是在金融的计算方面）都是十进制分数 1/10，1/100 等。二进制浮点数表示法并不能精确的表示类似 0.1 这样 的简单的数字，上诉代码的中的 x 和 y 的值非常接近最终的正确值，这种计算结果可以胜任大多数的计算任务：这个问题也只有在比较两个值是否相等时才会出现。  
javascript 的未来版本或许会支持十进制数字类型以避免这些舍入问题，在这之前，你更愿意使用大整数进行重要的金融计算，例如，要使用整数‘分’而不是使用小数‘元’进行货比单位的运算---------以上整理自《Javascript 权威指南 P37》

#### 安全范围

按照 JavaScript 中的数字格式，能够表示的证书范围是从-2⁵³~2⁵³，包含边界值，如果使用了超出此范围的整数，则无法保证低位数字的精度。

#### 解决方案

为了解决浮点数运算不准确的问题，在运算前我们把参加运算的数先升级(10 的 X 的次方)到整数，等运算完后再降级(0.1 的 X 的次方)。
对于整数，只要运算结果不超过 Math.pow(2, 53) 就不会丢失精度。
对于小数，解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）。

[:arrow_up:返回目录](#目录)

### JavaScript 中的变量在内存中的具体存储形式

在 JS 中，每一个数据都需要一个内存空间。内存空间又被分为两种，栈内存(stock)与堆内存(heap)。

#### 基础数据类型与栈内存

JS 中的基础数据类型，这些值都有固定的大小，往往都保存在栈内存中，由系统自动分配存储空间。我们可以直接操作保存在栈内存空间的值，因此基础数据类型都是按值访问。
数据在栈内存中的存储与使用方式类似于数据结构中的堆栈数据结构，遵循后进先出的原则。

```
基础数据类型： Number String Null Undefined Boolean
```

#### 引用数据类型与堆内存

引用数据类型的值是保存在堆内存中的对象。JavaScript 不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以粗浅地理解为保存在栈内存中的一个地址，该地址与堆内存的实际值相关联。

#### 内存空间管理

```
JavaScript的内存生命周期
1. 分配你所需要的内存
2. 使用分配到的内存（读、写）
3. 不需要时将其释放、归还
```

```
在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。
但是全局变量什么时候需要自动释放内存空间则很难判断，因此在我们的开发中，需要尽量避免使用全局变量，以确保性能问题。
```

| 栈内存                 | 堆内存                       |
| ---------------------- | ---------------------------- |
| 存储基础数据类型       | 存储引用数据类型             |
| 按值访问               | 按引用访问                   |
| 存储的值大小固定       | 存储的值大小不定，可动态调整 |
| 由系统自动分配内存空间 | 有程序员通过代码进行分配     |
| 主要用来执行程序       | 主要用来存放对象             |
| 空间小，运行效率高     | 空间大，但是运行效率相对较低 |
| 先进后出，后进先出     | 无需存储，可根据引用直接获取 |

[:arrow_up:返回目录](#目录)

### 理解值类型和引用类型

#### 1.JavaScript 值类型和引用类型有哪些

（1）值类型(基本类型)：数值(number)、布尔值(boolean)、null、undefined、string(在赋值传递中会以引用类型的方式来处理)。

```
undefined: 代表一切未知的事物，啥都没有，无法想象，代码也就更无法去处理了。
注意：typeof(undefined) 返回也是 undefined。
可以将undefined赋值给任何变量或属性，但并不意味了清除了该变量，反而会因此多了一个属性。

null: 有那么一个概念，但没有东西。无中似有，有中还无。虽难以想象，但已经可以用代码来处理了。
注意：typeof(null)返回object，但null并非object，具有null值的变量也并非object。

boolean: 是就是，非就非，没有疑义。对就对，错就错，绝对明确。既能被代码处理，也可以控制代码的流程。

number: 线性的事物，大小和次序分明，多而不乱。便于代码进行批量处理，也控制代码的迭代和循环等。
注意：typeof(NaN)和typeof(Infinity)都返回number 。
NaN参与任何数值计算的结构都是NaN，而且 NaN != NaN 。
Infinity / Infinity = NaN 。

string: 面向人类的理性事物，而不是机器信号。人机信息沟通，代码据此理解人的意图等等，都靠它了。
```

（2）引用类型：对象、数组、函数。

#### 2、如何理解值类型和引用类型

（1）值类型：变量的交换等于在一个新的地方按照连锁店的规范标准（统一店面理解为相同的变量内容）新开一个分店，这样新开的店与其它旧店互不相关、各自运营。
（2）引用类型：变量的交换等同于把现有一间店的钥匙（变量引用地址）复制一把给了另外一个老板，此时两个老板同时管理一间店，两个老板的行为都有可能对一间店的运营造成影响。

#### 3、值类型和引用类型的区别

(1)基本类型的值是一经确定就不可变的
(2)基本类型的比较是值的比较

```
只有在它们的值相等的时候它们才相等。
当比较的两个值的类型不同的时候==运算符会进行类型转换，但是当两个值的类型相同的时候，即使是==也相当于是===。
在用==比较两个不同类型的变量时会进行一些类型转换。如上的比较先会把true转换为数字1再和数字1进行比较，结果就是true了。
```

(3)基本类型的变量是存放在栈区的（栈区指内存里的栈内存）
(4)引用类型的值是可变的

```
可以为引用类型添加属性和方法，也可以删除其属性和方法。
引用类型可以拥有属性和方法，并且是可以动态改变的。
```

(5)引用类型的值是同时保存在栈内存和堆内存中的对象

```
js不同于其他语言，其不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间，
实际上，是操作对象的引用，所以引用类型的值是按引用访问的。
准确地说，引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，
栈区内存保存变量标识符和指向堆内存中该对象的指针，也可以说是该对象在堆内存的地址。
```

(6)引用类型的比较是引用的比较

```
引用类型是按引用访问的，换句话说就是比较两个对象的堆内存中的地址是否相同`
```

[:arrow_up:返回目录](#目录)

### <h3 id="dataObject">JavaScript 对象的底层数据结构是什么

#### 回归简单

要理解 JavaScript，首先放下对象和类的概念，回到数据和代码的本源。
JavaScript 中的数据很简单。简单数据只有 undefined，null，boolean，number 和 string 这五种，而复杂数据只有一种，即 object。这就好比中国古典的朴素唯物思想，世界最基本的元素归为金木水火土，其他复杂的物质都是由这五种组成。
JavaScript 中的代码只体现一种形式：function。

```
    注意：以上单词都是小写的，不要和Number，String，Object，Function等JavaScript内置函数混淆。
    要知道，JavaScript语言是区分大小写的！
```

#### 奇妙的对象

任何一个函数都可以为其动态地添加或去除属性，这些属性可以是简单类型，可以是对象，也可以是其他函数。也就是说，函数具有对象的全部特征，你完全可以把函数当对象来用。其实，函数就是对象，只不过比一般的对象多了一个括号“()”操作符，这个操作符用来执行函数的逻辑。即，函数本身还可以被调用，一般对象却不可以被调用，除此之外完全相同。

对象和函数可以象数组一样，用属性名或方法名作为下标来访问并处理。那么，它到底应该算是数组呢，还是算对象？

我们知道，**数组应该算是线性数据结构，线性数据结构一般有一定的规律，适合进行统一的批量迭代操作等，$\underline{有点像波}$**。**而对象是离散数据结构，适合描述分散的和个性化的东西，$\underline{有点像粒子}$**。因此，我们也可以这样问：JavaScript 里的对象到底是波还是粒子？

如果存在对象量子论，那么答案一定是：`波粒二象性`！

因此，JavaScript 里的函数和对象既有对象的特征也有数组的特征。这里的数组被称为“字典”，一种可以任意伸缩的名称值对儿的集合。其实， object 和 function 的内部实现就是一个字典结构，但这种字典结构却通过严谨而精巧的语法表现出了丰富的外观。正如量子力学在一些地方用粒子来解释和处理问题，而在另一些地方却用波来解释和处理问题。你也可以在需要的时候，自由选择用对象还是数组来解释和处理问题。只要善于把握 JavaScript 的这些奇妙特性，就可以编写出很多简洁而强大的代码来。

[:arrow_up:返回目录](#目录)

### 三种判断 JavaScript 数据类型的方式

- `typeof` 操作符，可以判断基本数据类型，对于引用数据类型全都返回 **Object**
- `instanceof` 操作符，**obj instanceof Object** 检测 Object.prototype 是否存在于参数 obj 的原型链上，主要用来判断变量是否是某个构造函数的实例，但是 Object 是所有对象的原型，所以在 obj instanceof Object 中，无论参数 obj 是数组还是函数都会返回 true
- `constructor` 是 prototype 对象上的属性，指向构造函数。根据实例对象寻找属性的顺序，若实例对象上没有实例属性或方法时，就去原型链上寻找，因此，实例对象也是能使用 constructor 属性的,同样的这个也只能输出构造函数

如需判断基本数据类型，使用 typeof，判断引用类型用 instanceof 和 constructor，实际上所有引用类型都是对象，只不过构造函数不同罢了，强行判断引用类型，要么只是判断常见的几种引用类型比如数组，函数，Date，正则等等，要么只能输出构造函数

```javascript{.line-numbers}
//classOf（）函数可以返回传递给他的任意对象
function classOf(o) {
  if (o === null) return "Null";
  if (o === undefined) return "Undefined";
  return Object.prototype.toString.call(o).slice(8, -1);
}
```

[:arrow_up:返回目录](#目录)

### 隐式类型转换的场景以及转换原则

`隐式转换一般说是Boolean转换`

- Boolean 场景，变量放在 if 的判断语句时，如果变量不是布尔值，那么就会发生隐式转换

  - String，非空字符串会转换成 true，空字符串会转换成 false
  - Number, 非 0 会转换成 true，0 会转换成 false
  - Object，任何对象都会转成 true

[:arrow_up:返回目录](#目录)

### 基本类型对应的内置对象，以及他们之间的装箱拆箱操作

这个说的是基本包装类型
只有原始值数字是原始值，**原始值不能有属性和方法**
属性和方法只有对象有，包括对象自己，数组，function

```javascript
var num = 123;
num.abc = "abc";
// 隐式转换 new Number(num).abc = 'abc'; --->随即delete
//
// new Number(num).abc --->  返回undefined
num.abc;
//上面这些隐式的过程就是包装类
```

原始值没有属性，当原始值调用属性时会看原始值对应的类型，再形成包装类
```javascript
var num = new Number();   //数字类型对象
var str = new String();  //字符串类型对象
var bol = new Boolean();  //布尔类型对象
```
**undefined和null不可以有属性**

[:arrow_up:返回目录](#目录)

### Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol